La tâche 1 est constituée de 4 questions, voici les choix de métriques correspondants ainsi qu'une justification pour chacune d'entre elles:

Q1. Pour répondre à cette question, nous avons décidé d'évaluer deux facteurs à l’aide de deux métriques.
En premier lieu, nous calculerons la densité des commentaires, DC, par rapport à la documentation du code :
ceci nous permettra d’identifier la quantité de documentation incluse dans chaque classe.
Évidemment, celle-ci doit être mise en relation avec la complexité de chaque classe,
chose qui sera calculée par CC (complexité cyclomatique). Nous avons choisi cette métrique car
elle donne une vue représentative globale de la complexité de chaque méthode.
Normalement, plus la classe est complexe, plus il y aura de documentation,
c’est-à-dire la densité de commentaires sera élevée.

Q2. La réponse à la deuxième interrogation, basée sur la conception modulaire, sera jaugée en fonction de deux métriques,
la première étant LCOM. Celle-ci nous fournira une représentation de la cohésion des classes Java.
Cette dernière est un élément principal dans l’évaluation de la modularité qui nous indiquera
qu’une classe s’occupe que d’une fonctionnalité et possède une responsabilité unique.
La deuxième métrique sera CBO puisqu’elle nous retournera le nombre de classes auxquelles une classe est
couplée. Le couplage (CBO) nous donne une indication par rapport aux variables, appels de méthodes et les liens d’héritage :
nous voulons que la cohésion soit forte et que le couplage soit faible pour affirmer que la conception soit modulaire.

Q3. Afin de déterminer la maturité du code, nous pouvons évaluer deux aspects intégraux de celui-ci,
soit la stabilité et la fiabilité, tel que vu en cours, à travers deux métriques. Une métrique appropriée pour la stabilité
du code serait les bugs trouvés, mesurés par la métrique NBAC. La stabilité du code est généralement proportionnelle au niveau
de maturité d’un programme. Le nombre de bugs attribuables à une classe identifiera cette stabilité. Quant à la fiabilité,
la métrique TPC est un bon indicateur de performance du code puisqu'elle nous retourne les tests réussis et la partie du code couverte
par ceux-ci. Plus la valeur TPC est élevée, plus la fiabilité l’est aussi.

Q4. La dernière question sera jugée en fonction des métriques PMNT et TPC.
La première nous indiquera quelles classes ne contiennent pas de tests et par conséquent, lesquelles ne peuvent être testées
automatiquement tel que demandé. La deuxième métrique sera réutilisée de la question 3 car elle nous permet de savoir le niveau de couverture du code.
La combinaison des deux métriques facilitera la tâche du mainteneur afin de savoir quelles classes sont testées adéquatement
et ne nécessitent pas de tests supplémentaires.

Mesures des métriques:
Afin de récolter les données, nous allons utiliser l'outil ckjm pour nous retourner les métriques WMC, CBO et LCOM.
La métrique NBAC sera évaluée à l'aide de l'outil SonarQube. Les métriques PMNT et TPC sont obtenues directement à l'aide
de l'éditeur IntelliJ Idea. Finalement, la métrique DC sera implémentée manuellement par nous-mêmes.
